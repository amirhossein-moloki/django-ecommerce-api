# تحلیل جامع سیستم فروشگاهی Hypex

## A) خلاصه مدیریتی (Executive Summary)

وضعیت کلی سیستم **قابل اتکا (Reliable)** ارزیابی می‌شود. معماری سیستم مدرن و ماژولار است و از بهترین شیوه‌ها (Best Practices) در توسعه نرم‌افزار مانند جداسازی دغدغه‌ها (Separation of Concerns)، تست‌نویسی مناسب و استفاده از ابزارهای استاندارد صنعتی پیروی می‌کند. منطق اصلی کسب‌وکار (Core Business Logic) به درستی پیاده‌سازی شده و مکانیزم‌های امنیتی و حفاظتی کلیدی در آن تعبیه شده است. با این حال، نقاطی برای بهبود، به خصوص در زمینه تست‌های پیشرفته و مدیریت پیکربندی، وجود دارد.

**۳ ریسک حیاتی اول:**

1.  **ریسک داده (Data Risk):** عدم وجود تست‌های یکپارچه برای سناریوهای بازگشت وجه (Refund) می‌تواند منجر به ناهماهنگی بین وضعیت سفارش و تراکنش مالی در صورت بروز خطا شود.
2.  **ریسک امنیت (Security Risk):** پیکربندی `ALLOWED_HOSTS='*'` در فایل نمونه `.env.example` یک ریسک امنیتی در محیط پروداکشن است، زیرا به حملات Host Header Injection اجازه می‌دهد.
3.  **ریسک مالی (Financial Risk):** نبود تست صریح برای Idempotency در Webhook پرداخت، هرچند که منطق آن در کد وجود دارد، ریسک پردازش تکراری یک تراکنش در شرایط خاص را به طور کامل از بین نمی‌برد.

**۳ پیشنهاد فوری:**

1.  **اصلاح پیکربندی امنیتی:** فایل `README.md` و مستندات استقرار به‌روزرسانی شوند تا به طور واضح بر لزوم تنظیم دقیق `ALLOWED_HOSTS` در محیط پروداکشن تأکید شود.
2.  **تکمیل تست‌های پرداخت:** یک تست یکپارچه برای Webhook پرداخت نوشته شود که به طور خاص، رفتار سیستم در هنگام دریافت چندباره یک تراکنش موفق را شبیه‌سازی و صحت عملکرد مکانیزم Idempotency را تأیید کند.
3.  **بررسی منطق Refund:** با توجه به اینکه هیچ کدی برای فرآیند بازگشت وجه یافت نشد، این قابلیت یا وجود ندارد یا در جایی خارج از کدبیس اصلی مدیریت می‌شود. لازم است این موضوع بررسی و در صورت نیاز، پیاده‌سازی و تست شود.

---

## B) نقشه سیستم (System Map)

**Tech Stack & Entry Points:**

*   **فریم‌ورک:** Django, Django REST Framework
*   **ORM/DB Driver:** Django ORM / `psycopg2`
*   **Queue:** Celery
*   **Cache:** Redis (`django-redis`)
*   **Payment SDK:** یک Gateway اختصاصی برای Zibal (در `payment/gateways.py`)
*   **نقاط ورود اصلی (Routes):**
    *   `ecommerce_api/urls.py` شامل مسیرهای اصلی است.
    *   `api/v1/`: مسیر اصلی API که خود به ماژول‌های دیگر تقسیم می‌شود.
    *   `auth/`: مسیرهای مربوط به احراز هویت (OTP، توکن JWT).
    *   `payment/`: مسیرهای مربوط به شروع و تأیید پرداخت و Webhook.
*   **Middlewares کلیدی:**
    *   `django_prometheus.middleware`: برای جمع‌آوری متریک‌ها.
    *   `corsheaders.middleware.CorsMiddleware`: برای مدیریت CORS.
    *   `cart.middleware.CartSessionMiddleware`: برای مدیریت سبد خرید کاربران لاگین‌نکرده.

**Domain Modules:**

*   **محصولات/دسته‌بندی (Products/Categories):**
    *   **مسیر:** `shop/`
    *   **مدل‌های اصلی:** `Product`, `Category` در `shop/models.py`
    *   **سرویس/منطق کلیدی:** `ProductViewSet` و `CategoryViewSet` در `shop/views.py` مسئولیت عملیات CRUD را بر عهده دارند.
*   **موجودی/انبار (Inventory):**
    *   **مسیر:** `shop/`
    *   **منطق کلیدی:** فیلد `stock` در مدل `Product` (`shop/models.py`). منطق کاهش موجودی در `OrderCreateSerializer` (`orders/serializers.py`) درون یک تراکنش اتمیک مدیریت می‌شود.
*   **سبد خرید (Cart):**
    *   **مسیر:** `cart/`
    *   **منطق کلیدی:** کلاس `Cart` در `cart/cart.py` که سبد خرید را بر اساس سشن (برای کاربران مهمان) یا کاربر لاگین‌کرده (با ذخیره در دیتابیس) مدیریت می‌کند.
*   **سفارش‌ها (Orders):**
    *   **مسیر:** `orders/`
    *   **مدل‌های اصلی:** `Order`, `OrderItem` در `orders/models.py`
    *   **سرویس/منطق کلیدی:** `create_order` در `orders/services.py` و `OrderCreateSerializer` در `orders/serializers.py` فرآیند ساخت سفارش را مدیریت می‌کنند.
*   **پرداخت (Payment):**
    *   **مسیر:** `payment/`
    *   **مدل اصلی:** وضعیت پرداخت روی مدل `Order` (`orders/models.py`) نگهداری می‌شود.
    *   **سرویس/منطق کلیدی:** `PaymentProcessAPIView` و `PaymentWebhookAPIView` در `payment/views.py` به ترتیب مسئول شروع پرداخت و دریافت Callback از درگاه هستند. منطق تأیید پرداخت در `verify_payment` در `payment/services.py` قرار دارد.
*   **تخفیف/کوپن (Coupons):**
    *   **مسیر:** `coupons/`
    *   **مدل اصلی:** `Coupon` در `coupons/models.py`
    *   **منطق کلیدی:** اعتبارسنجی و اعمال کوپن در `OrderCreateSerializer` (`orders/serializers.py`) انجام می‌شود.
*   **ارسال (Shipping):**
    *   **مسیر:** `shipping/`
    *   **منطق کلیدی:** یک تسک Celery برای ثبت بارنامه در Postex (`shipping/tasks.py`) وجود دارد که پس از پرداخت موفق فراخوانی می‌شود.
*   **مرجوعی/ریفاند (Refund):**
    *   **نتیجه:** **NOT FOUND IN CODE.** هیچ منطقی برای بازگشت وجه در کدبیس مشاهده نشد.
*   **کیف پول/اعتبار (Wallet):**
    *   **نتیجه:** **NOT FOUND IN CODE.**

---

## C) ممیزی صحت دامنه (Domain Correctness Audit)

**Pricing:**

*   **منبع قیمت و جلوگیری از دستکاری:** **OK.**
    *   **شواهد:** `orders/serializers.py` -> `OrderCreateSerializer.save`
    *   **توضیح:** قیمت نهایی محصول در زمان ساخت `OrderItem` به طور مستقیم از آبجکت قفل‌شده `Product` در دیتابیس (`product.price`) خوانده می‌شود و قیمت موجود در سبد خرید کاربر نادیده گرفته می‌شود. همچنین یک اعتبارسنجی صریح برای تطابق قیمت سبد و قیمت لحظه‌ای محصول وجود دارد که از هرگونه دستکاری جلوگیری می‌کند.
*   **محاسبه تخفیف، گرد کردن و واحد پول:** **OK.**
    *   **شواهد:** `orders/models.py` -> `Order.get_discount`
    *   **توضیح:** تخفیف بر اساس درصد کوپن از مجموع قیمت آیتم‌ها محاسبه می‌شود. واحد پول به صورت ثابت (`IRT`) در مدل `Order` تعریف شده است. محاسبات با استفاده از `Decimal` انجام می‌شود که از خطاهای ممیز شناور جلوگیری می‌کند.

**Inventory & Oversell Prevention:**

*   **قفل/رزرو موجودی:** **OK.**
    *   **شواهد:** `orders/serializers.py` -> `OrderCreateSerializer.save`
    *   **توضیح:** قبل از ساخت سفارش، تمام محصولات موجود در سبد خرید با استفاده از `select_for_update()` در یک تراکنش اتمیک (`transaction.atomic`) قفل می‌شوند. این کار تضمین می‌کند که هیچ دو درخواستی به طور همزمان نمی‌توانند موجودی یک محصول را تغییر دهند.
*   **رفتار در رقابت همزمان (Concurrency):** **OK.**
    *   **شواهد:** `orders/serializers.py` -> `OrderCreateSerializer.save`
    *   **توضیح:** پس از قفل کردن رکورد محصول، موجودی آن (`product.stock`) مجدداً بررسی می‌شود. این الگو تضمین می‌کند که حتی اگر دو درخواست همزمان برای آخرین آیتم موجودی یک محصول ارسال شوند، تنها یکی از آن‌ها موفق به ساخت سفارش خواهد شد و دیگری با خطای کمبود موجودی مواجه می‌شود.
*   **Rollback در خطای پرداخت:** **OK.**
    *   **شواهد:** `orders/models.py` -> `Order.save` و `Order.restore_stock`
    *   **توضیح:** اگر پرداخت ناموفق باشد و سفارش به وضعیت `Canceled` تغییر کند، متد `restore_stock` فراخوانی می‌شود که موجودی محصولات را به صورت اتمیک (با استفاده از `F()`) به انبار بازمی‌گرداند.
*   **سیاست انقضای رزرو موجودی (Stock Reservation Expiry):** **OK.**
    *   **شواهد:** `orders/tasks.py` -> `cancel_pending_orders`
    *   **توضیح:** یک تسک دوره‌ای Celery وجود دارد که سفارش‌های در وضعیت `Pending` را که برای مدت مشخصی (مثلاً ۲۰ دقیقه) پرداخت نشده‌اند، به طور خودکار لغو می‌کند و در نتیجه موجودی رزرو شده آن‌ها آزاد می‌شود.

**Cart → Order Integrity:**

*   **تبدیل سبد به سفارش (Snapshot):** **OK.**
    *   **شواهد:** `orders/serializers.py` -> `OrderCreateSerializer.save`
    *   **توضیح:** در زمان ساخت `OrderItem`، اطلاعات کلیدی محصول مانند `product_name`, `product_sku` و `price` در رکوردهای `OrderItem` کپی و ذخیره می‌شوند. این کار تضمین می‌کند که اگر اطلاعات محصول در آینده تغییر کند، تاریخچه سفارش دست‌نخورده باقی بماند.

**Order State Machine:**

*   **State های رسمی و انتقال‌های مجاز:** **OK.**
    *   **شواهد:** `orders/models.py` -> `Order.Status` و `Order._transitions`
    *   **توضیح:** یک ماشین وضعیت صریح با وضعیت‌های مشخص (`Pending`, `Paid`, `Processing`, ...) و قوانین انتقال مجاز بین آن‌ها (`_transitions`) تعریف شده است. متد `clean` در مدل `Order` از هرگونه انتقال وضعیت نامعتبر جلوگیری می‌کند.
*   **Audit Trail تغییر وضعیت:** **OK.**
    *   **شواهد:** `orders/models.py` -> `history = HistoricalRecords()`
    *   **توضیح:** پروژه از کتابخانه `django-simple-history` استفاده می‌کند که به طور خودکار تمام تغییرات روی مدل `Order` را ثبت می‌کند و یک تاریخچه کامل از تغییرات وضعیت و فاعل آن (actor) فراهم می‌کند.

**Payment Integration:**

*   **Webhook Handler و اعتبارسنجی:** **OK.**
    *   **شواهد:** `payment/views.py` -> `PaymentWebhookAPIView`
    *   **توضیح:** یک Webhook Handler برای درگاه پرداخت Zibal وجود دارد. این Handler دو مکانیزم امنیتی کلیدی را پیاده‌سازی کرده است: اعتبارسنجی امضای دیجیتال (`X-Gateway-Signature`) و بررسی IP مبدأ درخواست.
*   **جلوگیری از پرداخت تکراری (Idempotency):** **OK.**
    *   **شواهد:** `payment/views.py` -> `PaymentWebhookAPIView.post`
    *   **توضیح:** قبل از پردازش یک Webhook، سیستم بررسی می‌کند که آیا سفارشی با همان `track_id` قبلاً با موفقیت پردازش شده است یا خیر (`order.payment_status == Order.PaymentStatus.SUCCESS`). اگر پاسخ مثبت باشد، درخواست جدید را نادیده می‌گیرد و از پردازش تکراری جلوگیری می‌کند.
*   **Mapping Payment Status → Order Status:** **OK.**
    *   **شواهد:** `payment/services.py` -> `verify_payment`
    *   **توضیح:** پس از تأیید موفقیت‌آمیز پرداخت از طریق درگاه، سرویس `verify_payment` به طور صریح وضعیت پرداخت سفارش را به `SUCCESS` و وضعیت کلی سفارش را به `PAID` تغییر می‌دهد.
*   **Refund (کامل/جزئی):** **NOT FOUND IN CODE.**

---

## D) ممیزی امنیتی (Security Audit)

**AuthN/AuthZ:**

*   **روش احراز هویت:** **OK.**
    *   **شواهد:** `ecommerce_api/settings/base.py` -> `REST_FRAMEWORK`
    *   **توضیح:** سیستم از احراز هویت مبتنی بر توکن JWT (با استفاده از `rest_framework_simplejwt`) استفاده می‌کند که یک روش استاندارد و امن است.
*   **کنترل دسترسی (IDOR):** **OK.**
    *   **شواهد:** `orders/views.py` -> `OrderViewSet.get_queryset`
    *   **توضیح:** این متد کوئری سفارش‌ها را بر اساس کاربر لاگین‌کرده فیلتر می‌کند (`Order.objects.filter(user=user)`). این کار تضمین می‌کند که یک کاربر عادی هرگز نمی‌تواند به سفارش‌های کاربران دیگر دسترسی پیدا کند، حتی اگر ID آن را حدس بزند.

**Input Validation:**

*   **Schema Validation:** **OK.**
    *   **شواهد:** `orders/serializers.py` -> `OrderCreateSerializer`
    *   **توضیح:** تمام ورودی‌های API از طریق Serializer های DRF اعتبارسنجی می‌شوند. برای مثال، `OrderCreateSerializer` بررسی می‌کند که `address_id` معتبر و متعلق به کاربر فعلی باشد.
*   **File Upload Validation:** **OK.**
    *   **شواهد:** `shop/validators.py` -> `FileValidator`
    *   **توضیح:** اعتبارسنجی فایل‌های آپلود شده هم بر اساس حجم (`max_size`) و هم بر اساس نوع MIME واقعی فایل (با استفاده از `python-magic`) انجام می‌شود. این روش بسیار امن‌تر از اعتماد به پسوند فایل است.

**Secrets & Crypto:**

*   **نگهداری Secrets:** **OK.**
    *   **شواهد:** `ecommerce_api/settings/base.py` و `.env.example`
    *   **توضیح:** تمام اطلاعات حساس مانند `SECRET_KEY`، کلیدهای API و رمز عبور دیتابیس از طریق متغیرهای محیطی و با استفاده از `django-environ` مدیریت می‌شوند و در کد منبع هاردکد نشده‌اند.
*   **رمزنگاری درست (Password Hashing):** **OK.**
    *   **توضیح:** Django به طور پیش‌فرض از الگوریتم‌های هشینگ قوی و مدرن مانند PBKDF2 یا Argon2 برای ذخیره‌سازی رمزهای عبور استفاده می‌کند که استاندارد امنیتی بالایی را فراهم می‌کند.

**Rate limiting / Abuse:**

*   **جلوگیری از Brute-force (OTP):** **OK.**
    *   **شواهد:** `account/views.py` -> `RequestOTP`
    *   **توضیح:** بر روی اندپوینت درخواست OTP دو لایه محدودیت اعمال شده است: یکی بر اساس شماره تلفن (`1/2m`) و دیگری بر اساس IP (`5/m`). این مکانیزم به طور مؤثری از حملات Brute-force و ارسال اسپم OTP جلوگیری می‌کند.

---

## E) لایه داده و هماهنگی (Data Layer & Consistency)

*   **Schema Constraints:** **OK.**
    *   **شواهد:** `shop/models.py` -> `Review.Meta.constraints`
    *   **توضیح:** از محدودیت‌های دیتابیس مانند `UniqueConstraint` برای تضمین یکتایی داده‌ها (مثلاً هر کاربر فقط یک ریویو برای هر محصول) استفاده شده است.
*   **Index ها:** **OK.**
    *   **شواهد:** `orders/models.py` -> `Order.Meta.indexes`
    *   **توضیح:** بر روی فیلدهایی که به طور مکرر در کوئری‌ها استفاده می‌شوند (مانند `user` و `order_date` در مدل `Order`) ایندکس‌گذاری انجام شده است که به بهبود پرفورمنس کمک می‌کند.
*   **Transaction Boundaries:** **OK.**
    *   **شواهد:** `orders/serializers.py` -> `OrderCreateSerializer.save`
    *   **توضیح:** عملیات حساس و چندمرحله‌ای مانند ساخت سفارش و کاهش موجودی در یک بلاک `transaction.atomic` قرار گرفته‌اند تا تضمین شود که یا تمام عملیات با موفقیت انجام می‌شوند یا در صورت بروز خطا، هیچ‌کدام اعمال نمی‌شوند.
*   **N+1 و Pagination:** **OK.**
    *   **شواهد:** `orders/services.py` -> `get_user_orders`
    *   **توضیح:** در کوئری لیست سفارش‌ها از `prefetch_related` برای واکشی آبجکت‌های مرتبط (مانند `items` و `product`) استفاده شده است که به طور مؤثری از مشکل N+1 جلوگیری می‌کند. Pagination نیز به درستی پیاده‌سازی شده است.
*   **Soft Delete:** **OK.**
    *   **شواهد:** `shop/models.py` -> `Product` model
    *   **توضیح:** برای مدل `Product` از الگوی Soft Delete (با استفاده از فیلد `deleted_at`) استفاده شده است. این کار به جای حذف فیزیکی، رکورد را غیرفعال می‌کند که برای گزارش‌گیری و حفظ تاریخچه داده‌ها مفید است.

---

## F) قابلیت اطمینان و رصدپذیری (Reliability / Observability)

*   **Error Handling استاندارد:** **OK.**
    *   **شواهد:** `ecommerce_api/core/exceptions.py` -> `custom_exception_handler`
    *   **توضیح:** یک Exception Handler سفارشی وجود دارد که تمام خطاهای API را در یک فرمت استاندارد و یکپارچه JSON برمی‌گرداند.
*   **Logging ساخت‌یافته:** **OK.**
    *   **شواهد:** در فایل‌های مختلف مانند `payment/views.py` از `logging` استفاده شده است.
    *   **توضیح:** سیستم از مکانیزم لاگینگ استاندارد پایتون و جنگو استفاده می‌کند. لاگ‌های خطا به همراه اطلاعات کافی ثبت می‌شوند.
*   **Tracing/Metrics:** **OK.**
    *   **شواهد:** `ecommerce_api/settings/base.py`
    *   **توضیح:** پروژه با OpenTelemetry برای Tracing و با `django-prometheus` برای Metrics یکپارچه شده است که قابلیت رصد بالایی را فراهم می‌کند.

---

## G) عملکرد و مقیاس‌پذیری (Performance & Scalability)

*   **Caching Strategy:** **OK.**
    *   **شواهد:** `ecommerce_api/settings/base.py` -> `CACHES`
    *   **توضیح:** پروژه برای کشینگ از Redis استفاده می‌کند که به کاهش بار دیتابیس و افزایش سرعت پاسخ‌دهی کمک می‌کند.
*   **Queue/Background Jobs:** **OK.**
    *   **شواهد:** `orders/tasks.py`, `payment/tasks.py`
    *   **توضیح:** عملیات زمان‌بر مانند ارسال ایمیل تأیید سفارش و پردازش Webhook پرداخت به Celery واگذار شده‌اند تا ریسپانسیو بودن API حفظ شود.

---

## H) تست‌پذیری و پوشش کد (Testability & Coverage)

*   **تست‌های واحد/یکپارچه:** **OK.**
    *   **شواهد:** `orders/tests.py`
    *   **توضیح:** تست‌های خوبی برای منطق اصلی مانند محاسبه قیمت، ساخت سفارش و جلوگیری از فروش بیش از حد موجودی وجود دارد.
*   **تست برای Race-condition:** **PARTIAL.**
    *   **شواهد:** `orders/tests.py` -> `test_overselling_prevention`
    *   **توضیح:** یک تست برای اعتبارسنجی منطق جلوگیری از فروش مازاد وجود دارد، اما این یک تست واقعی همزمانی (Concurrency) نیست. با این حال، پوشش منطق کسب‌وکار کافی است.
*   **تست‌های امنیتی:** **OK.**
    *   **شواهد:** `orders/tests.py` -> `test_idor_vulnerability`
    *   **توضیح:** یک تست مشخص برای آسیب‌پذیری IDOR نوشته شده است که نشان‌دهنده آگاهی تیم توسعه از مسائل امنیتی است.

---

## یافته‌های عملیاتی (Actionable Findings)

**[Severity: P1] پیکربندی ناامن ALLOWED_HOSTS در محیط نمونه**

*   **Evidence:** `.env.example` -> `ALLOWED_HOSTS='*'`
    *   فایل نمونه برای متغیرهای محیطی، `ALLOWED_HOSTS` را بر روی مقدار `*` تنظیم کرده است که به هر هاستی اجازه اتصال می‌دهد.
*   **Impact:** امنیتی. این پیکربندی در محیط پروداکشن، وب‌سایت را در برابر حملات HTTP Host header injection آسیب‌پذیر می‌کند.
*   **Exploit/Repro:** یک مهاجم می‌تواند هدر `Host` را دستکاری کرده و از این طریق مکانیزم‌های کشینگ یا ارسال لینک بازنشانی رمز عبور را مسموم کند.
*   **Fix:** در فایل `.env.example` مقدار را به یک مقدار امن‌تر مانند `ALLOWED_HOSTS='yourdomain.com,www.yourdomain.com'` تغییر دهید و در مستندات (`README.md`) به شدت تأکید کنید که این مقدار باید برای محیط پروداکشن به درستی تنظیم شود.
*   **Regression tests:** این یک مورد پیکربندی است و تست خودکار برای آن معمولاً نوشته نمی‌شود، اما می‌توان یک چک در اسکریپت CI/CD اضافه کرد که اگر `DEBUG=False` باشد، مقدار `*` را برای `ALLOWED_HOSTS` مجاز نداند.

**[Severity: P2] عدم وجود تست یکپارچه برای Idempotency در Webhook پرداخت**

*   **Evidence:** `payment/tests.py` (وجود ندارد یا ناقص است) و `payment/views.py` -> `PaymentWebhookAPIView`
    *   منطق جلوگیری از پردازش تکراری در `PaymentWebhookAPIView` وجود دارد، اما هیچ تستی برای اطمینان از عملکرد صحیح آن در شرایط مختلف (مانند دریافت همزمان چند درخواست) نوشته نشده است.
*   **Impact:** داده/مالی. در شرایط بسیار نادر (مانند race condition در اولین پردازش)، ممکن است یک پرداخت تکراری ثبت شود و اعتبار کاربر دو بار شارژ گردد یا یک سفارش دو بار پردازش شود.
*   **Exploit/Repro:** یک اسکریپت بنویسید که دو درخواست POST یکسان را تقریباً به طور همزمان به اندپوینت Webhook ارسال کند و بررسی کنید که آیا سفارش فقط یک بار به وضعیت `Paid` منتقل می‌شود یا خیر.
*   **Fix:** یک تست در `payment/tests.py` اضافه کنید که:
    1.  یک سفارش با `track_id` مشخص بسازد.
    2.  یک بار Webhook موفق را برای آن ارسال کند و موفقیت را تأیید کند.
    3.  بلافاصله Webhook موفق دومی را با همان `track_id` ارسال کند.
    4.  تأیید کند که پاسخ دوم نیز `200 OK` است اما هیچ تغییری در وضعیت سفارش یا موجودی محصول ایجاد نشده است.
*   **Regression tests:** خود تست اضافه‌شده.

**[Severity: P2] عدم وجود قابلیت و منطق بازگشت وجه (Refund)**

*   **Evidence:** کل کدبیس.
    *   هیچ مدل، سرویس، ویو یا تستی مرتبط با فرآیند بازگشت وجه (کامل یا جزئی) در پروژه یافت نشد.
*   **Impact:** کسب‌وکار/UX. عدم امکان بازگشت وجه یک نقص بزرگ در یک سیستم فروشگاهی واقعی است و باعث نارضایتی مشتری و مشکلات عملیاتی می‌شود.
*   **Exploit/Repro:** کاربر پس از پرداخت موفق، درخواست لغو سفارش و بازگشت وجه را دارد. هیچ فرآیند سیستمی برای این کار وجود ندارد.
*   **Fix:**
    1.  یک مدل `Refund` برای ثبت درخواست‌های بازگشت وجه طراحی کنید.
    2.  یک سرویس برای ارتباط با درگاه پرداخت جهت انجام عملیات Refund پیاده‌سازی کنید.
    3.  وضعیت `REFUNDED` را به ماشین وضعیت `Order` اضافه کنید.
    4.  برای این فرآیند تست‌های کامل (واحد و یکپارچه) بنویسید.
*   **Regression tests:** تست‌هایی که سناریوهای مختلف ریفاند (کامل، جزئی، ناموفق) را پوشش دهند.

**[Severity: P2] عدم وجود تست برای لغو سفارش و بازگشت موجودی**

*   **Evidence:** `orders/tests.py`
    *   هیچ تستی برای سناریوی لغو یک سفارش (چه توسط کاربر و چه توسط سیستم) و تأیید بازگشت صحیح موجودی به انبار وجود ندارد.
*   **Impact:** داده. اگر منطق `restore_stock` در آینده دچار باگ شود، ممکن است موجودی محصولات به درستی بازنگردد و منجر به از دست رفتن فرصت فروش شود.
*   **Exploit/Repro:**
    1.  یک سفارش ایجاد کنید و موجودی محصول را بررسی کنید.
    2.  سفارش را به صورت دستی یا از طریق API به وضعیت `Canceled` ببرید.
    3.  موجودی محصول را مجدداً بررسی کنید و انتظار داشته باشید که به مقدار اولیه بازگشته باشد.
*   **Fix:** یک تست در `orders/tests.py` اضافه کنید که:
    1.  یک سفارش با چند آیتم ایجاد کند.
    2.  موجودی اولیه محصولات را ثبت کند.
    3.  وضعیت سفارش را به `Canceled` تغییر دهد.
    4.  تأیید کند که موجودی هر محصول به اندازه تعداد موجود در سفارش لغوشده افزایش یافته است.
*   **Regression tests:** خود تست اضافه‌شده.

**تعداد یافته‌ها:** پروژه از کیفیت بالایی برخوردار است و یافته‌های حیاتی (P0) در آن مشاهده نشد. با این حال، ۴ یافته عملیاتی (P1/P2) شناسایی شد که برای رسیدن به سطح استانداردهای پروداکشن، نیازمند توجه هستند.
