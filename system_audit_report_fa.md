
# گزارش حسابرسی فنی سیستم فروشگاهی

## A) خلاصه مدیریتی

**وضعیت کلی سیستم:** قابل اتکا. معماری سیستم بر اساس اصول خوبی بنا شده است. استفاده از لایه سرویس، تراکنش‌های اتمی در عملیات‌های حساس و جداسازی منطقی ماژول‌ها، از نقاط قوت پروژه است. با این حال، حوزه‌هایی برای بهبود، به خصوص در زمینه اعتبارسنجی ورودی‌ها و پیاده‌سازی کامل‌تر سیاست‌های امنیتی وجود دارد.

**۳ ریسک حیاتی اول:**

1.  **ریسک امنیتی (P1):** فقدان محدودیت نرخ (Rate Limiting) روی نقاط حساس مانند درخواست OTP و اعمال کوپن، سیستم را در برابر حملات Brute-force آسیب‌پذیر می‌کند.
2.  **ریسک داده (P1):** عدم وجود قفل توزیع‌شده (Distributed Lock) در عملیات ساخت سفارش، در شرایط بار بسیار بالا (High Concurrency) می‌تواند منجر به فروش بیش از موجودی (Overselling) شود، هرچند استفاده از `select_for_update` ریسک را در حالت تک-نمونه (single-instance) کاهش می‌دهد.
3.  **ریسک مالی (P2):** منطق بازگرداندن موجودی در زمان لغو سفارش، در صورتی که سفارش در مراحل ارسال باشد، می‌تواند منجر به ناهماهنگی بین موجودی انبار و سیستم شود.

**۳ پیشنهاد فوری:**

1.  **پیاده‌سازی Rate Limiting:** در اسرع وقت، روی اندپوینت‌های `auth/request-otp/` و `coupons/apply-coupon/` محدودیت نرخ بر اساس IP و شماره تلفن اعمال شود.
2.  **بررسی مجدد منطق IDOR:** اطمینان حاصل شود که تمام ViewSetها، به خصوص آن‌هایی که با داده‌های کاربر سروکار دارند، به درستی با فیلتر کردن `queryset` بر اساس `request.user` از دسترسی غیرمجاز به داده‌های دیگران جلوگیری می‌کنند.
3.  **تکمیل چرخه پرداخت:** منطق مربوط به بازگشت وجه (Refund) و مدیریت خطاهای شبکه در ارتباط با درگاه پرداخت به سیستم اضافه شود.

## B) نقشه سیستم

**پشته فناوری و نقاط ورود:**

*   **فریم‌ورک:** Django, Django REST Framework
*   **ORM/DB Driver:** Django ORM / `psycopg2`
*   **صف:** Celery
*   **کش:** Redis (`django-redis`)
*   **پرداخت:** پیاده‌سازی مستقیم برای درگاه زیبال (Zibal)
*   **نقطه ورود درخواست‌ها:** `ecommerce_api/urls.py` که به ترتیب URLهای هر اپلیکیشن (shop, cart, orders, ...) را `include` می‌کند.
*   **Middlewares:** `PrometheusBeforeMiddleware`, `PrometheusAfterMiddleware`, `SessionMiddleware`, `CorsMiddleware`, `CartSessionMiddleware`, `AuthenticationMiddleware`

**ماژول‌های دامنه شناسایی‌شده:**

*   **محصولات/دسته‌بندی:**
    *   **مسیر:** `shop/`
    *   **توابع کلیدی:** `ProductViewSet`, `CategoryViewSet`, `ReviewViewSet`, `services.get_product_detail`, `services.create_review`
*   **موجودی/انبار:**
    *   **مسیر:** `shop/models.py`
    *   **منطق:** فیلد `Product.stock` و فیلتر `InStockFilterBackend`
*   **سبد خرید:**
    *   **مسیر:** `cart/`
    *   **توابع کلیدی:** `CartViewSet`, `cart.cart.Cart`, `services.add_to_cart`
*   **سفارش‌ها:**
    *   **مسیر:** `orders/`
    *   **توابع کلیدی:** `OrderViewSet`, `services.create_order`, `OrderCreateSerializer.save`
*   **پرداخت:**
    *   **مسیر:** `payment/`
    *   **توابع کلیدی:** `PaymentProcessAPIView`, `PaymentWebhookAPIView`, `services.process_payment`, `services.verify_payment`
*   **ارسال:**
    *   **مسیر:** `shipping/` (تحلیل کامل انجام نشده، اما ماژول وجود دارد)
*   **تخفیف/کوپن:**
    *   **مسیر:** `coupons/`
    *   **توابع کلیدی:** `CouponViewSet`, `services.apply_coupon`
*   **مرجوعی/ریفاند:** **NOT FOUND IN CODE**
*   **کیف پول/اعتبار:**
    *   **مسیر:** `account/models.py`
    *   **منطق:** فیلد `Profile.balance` (پیاده‌سازی اولیه)

## C) حسابرسی صحت دامنه

*   **قیمت‌گذاری:**
    *   **منبع قیمت:** `shop/models.py` -> `Product.price`. قیمت در زمان ساخت سفارش در `orders/models.py` -> `OrderItem.price` ذخیره (snapshot) می‌شود. **OK**
    *   **محاسبه تخفیف:** بر اساس درصد در `coupons/models.py` -> `Coupon.discount`. سیاست گرد کردن (rounding) مشخصی یافت نشد. واحد پول به صورت ثابت `IRT` است. **PARTIAL**
    *   **مالیات/ارسال:** مقادیر ثابت در `orders/serializers.py` -> `OrderCreateSerializer.save` در نظر گرفته شده است. **PARTIAL**
*   **موجودی و جلوگیری از فروش بیش از حد:**
    *   **قفل/رزرو موجودی:** استفاده از `select_for_update` در `orders/serializers.py` -> `OrderCreateSerializer.save` برای قفل کردن ردیف‌های محصول. **OK**
    *   **رفتار در رقابت همزمان:** تراکنش اتمی و قفل سطح دیتابیس، ریسک را کاهش می‌دهد. **OK**
    *   **Rollback در خطای پرداخت:** کل فرآیند ساخت سفارش در `transaction.atomic` قرار دارد و در صورت خطا، تغییرات (از جمله کسر از موجودی) بازگردانده می‌شود. **OK**
    *   **سیاست انقضای رزرو موجودی:** برای سفارش‌های در حالت `pending`، سیاستی برای آزادسازی موجودی پس از مدتی مشخص، یافت نشد. **NOT FOUND IN CODE**
*   **یکپارچگی سبد خرید → سفارش:**
    *   **تبدیل سبد به سفارش:** قیمت محصول در `OrderItem` ذخیره می‌شود، اما نام و SKU به صورت `ForeignKey` هستند و در صورت تغییر محصول اصلی، در سفارش‌های قبلی نیز تغییر می‌کنند. **PARTIAL**
    *   **جلوگیری از سبد خرید کهنه:** قیمت و موجودی در لحظه خرید در `orders/serializers.py` -> `OrderCreateSerializer.save` مجددا اعتبارسنجی می‌شوند. **OK**
    *   **Validation نهایی:** تمام موارد (موجودی، قیمت، کوپن) قبل از ساخت `Order` اعتبارسنجی می‌شوند. **OK**
*   **ماشین وضعیت سفارش:**
    *   **Stateها و انتقال‌های مجاز:** در `orders/models.py` -> `Order._transitions` تعریف و در متد `clean` اعمال می‌شود. **OK**
    *   **Audit trail:** با استفاده از `simple_history` روی مدل `Order` پیاده‌سازی شده است. **OK**
    *   **Idempotency:** وب‌هوک پرداخت یک بررسی اولیه برای جلوگیری از پردازش مجدد دارد، اما عملیات‌های دیگر مانند ارسال یا لغو، فاقد این ویژگی هستند. **PARTIAL**
*   **یکپارچگی درگاه پرداخت:**
    *   **Webhook handler:** در `payment/views.py` -> `PaymentWebhookAPIView` پیاده‌سازی شده و امضای وب‌هوک اعتبارسنجی می‌شود. **OK**
    *   **جلوگیری از پرداخت تکراری:** با بررسی `order.payment_status` در وب‌هوک، از پردازش مجدد جلوگیری می‌شود. **OK**
    *   **Mapping وضعیت پرداخت به سفارش:** در `payment/services.py` -> `verify_payment` انجام می‌شود. **OK**
    *   **Handling تایم‌اوت/خطای جزئی:** منطق مشخصی برای مدیریت این موارد یافت نشد. **NOT FOUND IN CODE**
    *   **Refund:** تابعی برای بازگشت وجه کامل یا جزئی یافت نشد. **NOT FOUND IN CODE**

## D) حسابرسی امنیتی

*   **احراز هویت و کنترل دسترسی (AuthN/AuthZ):**
    *   **روش احراز هویت:** JWT با `rest_framework_simplejwt` و OTP مبتنی بر شماره تلفن.
    *   **کنترل دسترسی:** از `IsOwnerOrStaff` و `IsAdminUser` برای محدود کردن دسترسی به منابعی مانند سفارش‌ها استفاده شده است. **OK**
    *   **IDOR check:** در `OrderViewSet` و `ProductViewSet` با فیلتر کردن `queryset` بر اساس کاربر لاگین‌کرده، جلوی IDOR گرفته شده است. نیاز به بررسی تمام اندپوینت‌ها برای اطمینان کامل است. **PARTIAL**
*   **اعتبارسنجی ورودی (Input Validation):**
    *   **Schema validation:** با استفاده از سریالایزرهای DRF انجام می‌شود. **OK**
    *   **File upload validation:** برای آپلود تصویر محصول و پروفایل، اعتبارسنجی حجم و نوع فایل وجود دارد. **OK**
    *   **منع Mass assignment:** سریالایزرها به طور پیش‌فرض از این آسیب‌پذیری جلوگیری می‌کنند. **OK**
*   **تزریق و SSRF (Injection & SSRF):**
    *   **SQL injection:** به دلیل استفاده از Django ORM، سیستم در برابر SQL injection مقاوم است. **OK**
    *   **SSRF:** ارتباط با درگاه پرداخت از URL ثابتی استفاده می‌کند و ریسک SSRF وجود ندارد. **OK**
    *   **Command injection:** از دستورات سیستمی استفاده نشده است. **OK**
*   **اسرار و رمزنگاری (Secrets & Crypto):**
    *   **نگهداری Secrets:** از طریق متغیرهای محیطی و `django-environ` مدیریت می‌شود. **OK**
    *   **رمزنگاری درست:** برای هش کردن پسوردها از مکانیزم پیش‌فرض جنگو استفاده شده که امن است. **OK**
    *   **Token rotation/expiry:** `simple_jwt` برای چرخاندن (rotate) و باطل کردن refresh tokenها تنظیم شده است. **OK**
*   **محدودیت نرخ و سوءاستفاده (Rate limiting / Abuse):**
    *   **جلوگیری از Brute-force لاگین/OTP:** در `account/views.py` -> `VerifyOTP`، پس از ۵ تلاش ناموفق، OTP غیرفعال می‌شود، اما روی اندپوینت درخواست OTP (`RequestOTP`) هیچ محدودیتی وجود ندارد. **PARTIAL**
    *   **Rate limit روی checkout/payment:** محدودیت نرخ خاصی روی این اندپوینت‌ها یافت نشد. **NOT FOUND IN CODE**
    *   **Captcha/lockout policy:** یافت نشد. **NOT FOUND IN CODE**

## E) لایه داده و یکپارچگی

*   **Schema constraints:** از `ForeignKey` و `UniqueConstraint` استفاده شده است. **OK**
*   **Indexها:** روی فیلدهایی که زیاد مورد کوئری قرار می‌گیرند، ایندکس تعریف شده است. **OK**
*   **Transaction boundaries:** در فرآیند ساخت سفارش از `transaction.atomic` استفاده شده است. **OK**
*   **N+1:** با استفاده از `prefetch_related` و `select_related` در ViewSetها، از این مشکل جلوگیری شده است. **OK**
*   **Soft delete vs hard delete:** کوپن‌ها به صورت soft-delete حذف می‌شوند (`active=False`)، اما سایر مدل‌ها از hard-delete استفاده می‌کنند. **PARTIAL**

## F) قابلیت اطمینان و مشاهده‌پذیری

*   **Error handling:** از یک exception handler سفارشی در `ecommerce_api.core.exceptions.custom_exception_handler` استفاده شده است. **OK**
*   **Logging:** لاگینگ ساخت‌یافته (Structured logging) در سراسر پروژه استفاده شده است. **OK**
*   **Tracing/metrics:** `OpenTelemetry` برای tracing و `django-prometheus` برای metrics تنظیم شده‌اند. **OK**
*   **Retries/timeouts/circuit breaker:** مکانیزم مشخصی برای تلاش مجدد یا مدیریت وقفه در ارتباط با سرویس‌های خارجی (پرداخت، پیامک) یافت نشد. **NOT FOUND IN CODE**

## G) عملکرد و مقیاس‌پذیری

*   **Caching strategy:** از Redis برای کش کردن لیست محصولات، جزئیات محصول و لیست دسته‌بندی‌ها استفاده می‌شود. **OK**
*   **Queue/background jobs:** از Celery برای کارهای زمان‌بر مانند ارسال ایمیل تایید سفارش و ساخت محموله پستی استفاده می‌شود. **OK**
*   **Hot paths:** فرآیند ساخت سفارش به دلیل قفل کردن دیتابیس، یک گلوگاه بالقوه است. **PARTIAL**

## H) قابلیت تست و پوشش کد

پروژه دارای تست‌های واحد و یکپارچه برای هر اپلیکیشن است. تحلیل دقیق پوشش تست و کیفیت تست‌ها خارج از محدوده این حسابرسی است، اما وجود ساختار تست یک نقطه قوت محسوب می‌شود.

---

## یافته‌های عملی (Actionable Findings)

**[Severity: P1] فقدان Rate Limiting روی اندپوینت درخواست OTP**
*   **Evidence:** `account/views.py` → `RequestOTP`
    *   این ویو بدون هیچ‌گونه محدودیتی، به ازای هر درخواست، یک OTP جدید ساخته و از طریق سرویس پیامک ارسال می‌کند.
*   **Impact:** امنیتی/مالی. یک مهاجم می‌تواند با ارسال درخواست‌های مکرر، هزینه زیادی بابت ارسال پیامک به شرکت تحمیل کرده و یا شماره تلفن کاربران را اسپم کند.
*   **Exploit/Repro:**
    1.  یک اسکریپت ساده بنویسید که اندپوینت `auth/request-otp/` را با یک شماره تلفن مشخص، ۱۰۰ بار در دقیقه فراخوانی کند.
    2.  مشاهده خواهید کرد که ۱۰۰ پیامک ارسال می‌شود.
*   **Fix:** از `django-ratelimit` یا `djangorestframework-simple-api-key` برای اعمال محدودیت نرخ (مثلاً ۱ درخواست در هر ۲ دقیقه به ازای هر شماره تلفن) استفاده کنید.
*   **Regression tests:** یک تست بنویسید که نشان دهد پس از یک درخواست موفق، درخواست دوم در بازه زمانی مشخص با خطای 429 (Too Many Requests) مواجه می‌شود.

**[Severity: P1] عدم وجود قفل توزیع‌شده برای جلوگیری از Overselling در محیط کلاستر**
*   **Evidence:** `orders/serializers.py` → `OrderCreateSerializer.save`
    *   استفاده از `select_for_update` برای قفل کردن محصولات، تنها در یک نمونه (instance) از اپلیکیشن کارایی دارد. در محیطی با چند replica، این قفل مانع از پردازش همزمان سفارش برای یک محصول توسط replicaهای مختلف نمی‌شود.
*   **Impact:** مالی/داده. در شرایط بار بالا، ممکن است یک محصول بیشتر از موجودی واقعی آن فروخته شود که منجر به نارضایتی مشتری و مشکلات عملیاتی می‌شود.
*   **Exploit/Repro:**
    1.  اپلیکیشن را در دو replica جداگانه اجرا کنید.
    2.  یک محصول با موجودی ۱ ایجاد کنید.
    3.  به صورت همزمان از هر دو replica، درخواست ساخت سفارش برای آن محصول را ارسال کنید.
    4.  این احتمال وجود دارد که هر دو سفارش با موفقیت ثبت شوند.
*   **Fix:** از یک مکانیزم قفل توزیع‌شده مبتنی بر Redis (مانند Redlock) قبل از ورود به تراکنش دیتابیس استفاده کنید.
*   **Regression tests:** یک تست یکپارچه بنویسید که سناریوی Exploit را شبیه‌سازی کرده و اطمینان حاصل کند که تنها یک درخواست موفق می‌شود.

**[Severity: P2] عدم اسنپ‌شات کامل اطلاعات محصول در آیتم سفارش**
*   **Evidence:** `orders/models.py` → `OrderItem`
    *   این مدل فقط `price` را ذخیره می‌کند. `product` به صورت `ForeignKey` است. اگر نام یا SKU محصول در آینده تغییر کند، این تغییر در سفارش‌های قبلی نیز منعکس می‌شود.
*   **Impact:** داده/UX. گزارش‌گیری از سفارش‌های قدیمی ممکن است با اطلاعات نادرست انجام شود و فاکتورهای مشتریان اطلاعات متناقضی نمایش دهند.
*   **Exploit/Repro:**
    1.  یک سفارش برای محصول "کفش نایک" ثبت کنید.
    2.  نام محصول را در پنل ادمین به "کفش آدیداس" تغییر دهید.
    3.  جزئیات سفارش قبلی را مشاهده کنید. نام محصول به "کفش آدیداس" تغییر کرده است.
*   **Fix:** در مدل `OrderItem`، فیلدهای `product_name` و `product_sku` را اضافه کرده و در زمان ساخت سفارش، آن‌ها را با مقادیر فعلی محصول پر کنید.
*   **Regression tests:** تستی بنویسید که پس از تغییر نام محصول، بررسی کند که نام محصول در `OrderItem` سفارش قبلی ثابت باقی مانده است.

**[Severity: P2] عدم مدیریت خطاهای شبکه در ارتباط با سرویس‌های خارجی**
*   **Evidence:** `payment/gateways.py` → `ZibalGateway`
    *   درخواست‌های `requests.post` فاقد `timeout` هستند و مکانیزم `retry` برای خطاهای موقتی شبکه (مانند 502, 503) وجود ندارد.
*   **Impact:** قابلیت اطمینان (Reliability). در صورت بروز مشکل در شبکه یا سرویس زیبال، اپلیکیشن ممکن است برای مدت طولانی منتظر پاسخ بماند و منابع را اشغال کند. همچنین خطاهای موقتی منجر به شکست دائمی عملیات می‌شوند.
*   **Exploit/Repro:** با استفاده از ابزاری مانند `mitmproxy`، پاسخ از سرور زیبال را با تاخیر زیاد یا با خطای 503 شبیه‌سازی کنید.
*   **Fix:** برای تمام درخواست‌های خارجی، `timeout` (مثلاً ۵ ثانیه) تنظیم کنید و از کتابخانه‌ای مانند `requests.adapters.HTTPAdapter` با `Retry` برای تلاش مجدد در خطاهای قابل بازیابی استفاده نمایید.
*   **Regression tests:** با استفاده از `mock`، خطاهای شبکه را شبیه‌سازی کرده و اطمینان حاصل کنید که مکانیزم `retry` به درستی عمل می‌کند.

**[Severity: P2] منطق ناکافی برای بازگرداندن موجودی**
*   **Evidence:** `orders/models.py` → `Order.save`
    *   هنگام کنسل شدن سفارش، موجودی محصول بازگردانده می‌شود، اما وضعیت ارسال (shipping) چک نمی‌شود.
*   **Impact:** داده/مالی. اگر سفارشی که ارسال شده است، کنسل شود، موجودی به اشتباه به انبار مجازی بازمی‌گردد در حالی که محصول فیزیکی ارسال شده است.
*   **Exploit/Repro:**
    1.  وضعیت یک سفارش را به `shipped` تغییر دهید.
    2.  سپس وضعیت آن را به `canceled` تغییر دهید.
    3.  موجودی محصول مربوطه در سیستم یک واحد افزایش می‌یابد.
*   **Fix:** در متد `restore_stock`، بررسی کنید که `self.status` قبل از تغییر به `canceled`، در وضعیت‌های `shipped` یا `delivered` نباشد.
*   **Regression tests:** تستی اضافه کنید که سناریوی بالا را اجرا کرده و اطمینان حاصل کند که در صورت ارسال شدن سفارش، موجودی بازگردانده نمی‌شود.

**[Severity: P2] عدم وجود محدودیت نرخ روی اندپوینت اعمال کوپن**
*   **Evidence:** `coupons/views.py` → `CouponViewSet.apply`
    *   این اندپوینت که برای عموم قابل دسترس است، فاقد هرگونه محدودیت نرخ است.
*   **Impact:** امنیتی. یک مهاجم می‌تواند با تست کردن کدهای مختلف، کدهای تخفیف معتبر را پیدا کند (Coupon enumeration).
*   **Exploit/Repro:** یک اسکریپت بنویسید که در یک حلقه، کدهای تخفیف احتمالی را به اندپوینت `apply-coupon/` ارسال کرده و پاسخ‌ها را تحلیل کند.
*   **Fix:** روی این اندپوینت، محدودیت نرخ بر اساس IP (مثلاً ۱۰ درخواست در دقیقه) اعمال کنید.
*   **Regression tests:** تستی بنویسید که نشان دهد پس از ۱۰ درخواست ناموفق، درخواست یازدهم با خطای 429 مواجه می‌شود.

**[Severity: P3] استفاده از مقادیر ثابت برای هزینه ارسال و مالیات**
*   **Evidence:** `orders/serializers.py` → `OrderCreateSerializer.save`
    *   `order.shipping_cost` و `order.tax_amount` با مقادیر ثابت (`15.00` و `9%`) پر می‌شوند.
*   **Impact:** کسب‌وکار. این منطق برای یک سیستم واقعی انعطاف‌پذیر نیست و نیاز به تغییر کد برای هرگونه تغییر در سیاست‌های مالیاتی یا هزینه ارسال دارد.
*   **Fix:** این مقادیر را از یک سرویس یا تنظیمات داینامیک دریافت کنید. به عنوان مثال، یک مدل `ShippingMethod` و `TaxRate` ایجاد کنید.
*   **Regression tests:** تست‌هایی برای محاسبه هزینه ارسال و مالیات بر اساس سناریوهای مختلف (شهرهای مختلف، نرخ‌های مالیاتی متفاوت) بنویسید.

**[Severity: P3] عدم وجود سیاست انقضای رزرو موجودی**
*   **Evidence:** `orders/models.py`
    *   هیچ مکانیزمی برای لغو خودکار سفارش‌های `pending` که پس از مدتی پرداخت نمی‌شوند، وجود ندارد.
*   **Impact:** کسب‌وکار/UX. موجودی محصولات برای سفارش‌های ناموفق قفل باقی می‌ماند و برای مشتریان دیگر در دسترس نخواهد بود.
*   **Fix:** یک Celery task دوره‌ای (periodic task) ایجاد کنید که سفارش‌های `pending` قدیمی‌تر از X دقیقه (مثلاً ۲۰ دقیقه) را پیدا کرده و وضعیت آن‌ها را به `canceled` تغییر دهد تا موجودی آزاد شود.
*   **Regression tests:** تستی بنویسید که یک سفارش `pending` ایجاد کرده، زمان را جلو ببرد و بررسی کند که آیا وظیفه Celery به درستی آن را لغو می‌کند یا خیر.

**[Severity: P3] عدم وجود مدیریت خطا برای ارسال ایمیل**
*   **Evidence:** `orders/services.py` → `create_order`
    *   وظیفه Celery برای ارسال ایمیل (`send_order_confirmation_email.delay`) بدون هیچ‌گونه بررسی خطا فراخوانی می‌شود.
*   **Impact:** قابلیت اطمینان. اگر سرویس Celery یا Redis در دسترس نباشد، فرآیند ساخت سفارش با خطا مواجه خواهد شد.
*   **Fix:** فراخوانی وظیفه Celery را در یک بلوک `try...except` قرار دهید و در صورت بروز خطا، آن را لاگ کنید اما اجازه دهید فرآیند ساخت سفارش ادامه یابد (ارسال ایمیل یک عملیات حیاتی نیست).
*   **Regression tests:** با `mock` کردن `send_order_confirmation_email.delay` و ایجاد یک استثنا، بررسی کنید که ساخت سفارش همچنان با موفقیت انجام می‌شود.

**[Severity: P3] عدم اعتبارسنجی مجدد کوپن در لحظه ساخت سفارش**
*   **Evidence:** `orders/serializers.py` → `OrderCreateSerializer.save`
    *   کوپن در متد `validate` اعتبارسنجی می‌شود، اما بین زمان اعتبارسنجی و زمان ذخیره نهایی سفارش، ممکن است وضعیت کوپن (مثلاً `usage_count`) تغییر کند.
*   **Impact:** مالی. در شرایط رقابتی، ممکن است یک کوپن با ظرفیت محدود، بیش از حد مجاز استفاده شود.
*   **Fix:** قبل از `order.save()`، کوپن را مجدداً از دیتابیس با `select_for_update` خوانده و شرایط آن را دوباره بررسی کنید.
*   **Regression tests:** یک تست بنویسید که در آن دو کاربر به صورت همزمان سعی در استفاده از یک کوپن با ظرفیت ۱ دارند و اطمینان حاصل کنید که فقط یکی از آن‌ها موفق می‌شود.
