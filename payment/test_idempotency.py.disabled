import pytest
from unittest.mock import patch
from django.urls import reverse
from rest_framework import status
from orders.factories import OrderFactory
from orders.models import Order

pytestmark = pytest.mark.django_db


@patch('payment.gateways.ZibalGateway.verify_payment')
def test_replay_attack_is_prevented(mock_verify_payment, api_client, user):
    """
    Ensure that processing the same successful verification multiple times
    does not result in multiple successful payments for the same order.
    """
    order = OrderFactory.create(user=user, total_payable=10000, payment_status=Order.PaymentStatus.PENDING)
    track_id = 'test-track-id'
    order.payment_track_id = track_id
    order.save()

    # Mock the Zibal gateway to return a successful verification
    mock_verify_payment.return_value = {
        'result': 100,  # Success
        'amount': int(order.total_payable * 10),
        'orderId': str(order.order_id),
        'refNumber': 'mock-ref-number'
    }

    # Simulate the first successful verification
    url = f"{reverse('payment:verify')}?trackId={track_id}&success=1"
    response = api_client.get(url)

    # Check that the first verification was successful
    assert response.status_code == status.HTTP_200_OK
    order.refresh_from_db()
    assert order.payment_status == Order.PaymentStatus.SUCCESS

    # Simulate a replay attack by sending the same verification request again
    response_replay = api_client.get(url)

    # Check that the replay attempt was also successful, but did not re-process the payment
    assert response_replay.status_code == status.HTTP_200_OK
    assert "already been successfully verified" in response_replay.data['message']

    # Assert that the Zibal gateway's verify_payment method was only called once
    assert mock_verify_payment.call_count == 1
